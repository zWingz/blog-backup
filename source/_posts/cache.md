---
title: webpack打包后服务器缓存问题浅谈
date: "2017-4-27 17:31:48"
tags: [前端,问题及思考]
---
**背景:**
现阶段服务器缓存的方法(以nginx为例)

 1. 配置 expires或者Cache-Control.
   通俗来讲这是在浏览器请求静态文件的时候.服务器会在响应头带上
   Cache-Control:max-age=15552000
   或者
   Expires:Tue, 24 Oct 2017 09:40:28 GMT
   浏览器下次再请求该资源的时候,会判断cache是否过期.如果不过期则显示为200 from memory cache.
   这种配置完全由浏览器判断是否需要重新下载文件.
   好处是不会有多余的请求,节省流量
   坏处是需要由前端来做版本控制(做版本控制需要借助工具)


 2. 配置last-modified或者etag
   通俗来讲这是在浏览器请求静态文件的时候,服务器在响应头上带上Last-Modified或者Etag
   浏览器下次在请求该资源时候.服务器接受到请求会先根据etag或者lastModified判断所请求的资源是否修改过.如果没有则返回304 Not modified.如果跟最新资源不一致则返回200以及新的资源文件.这种配置就是浏览器无论如何都会发送一个请求给服务器.具体需不需要重新下载文件则交由服务器判断.
(更具体的请自行谷歌)
   好处是前端不需要进行版本控制
   坏处是每次都必须发送请求到服务器



<!-- more -->



**我所遇到的问题:**

当我的nginx设置 cache-control: public;
这时候说明浏览器可以缓存所有静态资源.
而请求静态资源时候会200 from memory cache 和 304 not modified 随机出现
再加上webpack打包会自动加上hash.
那么正常情况下.就算我改动其中一个文件.并不会引起其他文件变化.
但问题来了.
只要我用webpack build一次.会将dist/文件夹清空,然后再重新生成文件.
那么对服务器来说.你所有文件都已经修改过了.而不管你内容有没有变化.
这时候浏览器便会将所有资源重新下载,而不是正常情况下,哪个更新下载哪个.其余的通过缓存获取.

**如何重现问题**

将nginx设置 add_header Cache-Control no-cache; etag on;即关闭cache,同时开启etag;
此时可以改动某个文件的代码然后重新build一遍.观察浏览器network中js文件的缓存情况


**解决方法**

将cache-control设成max-age=12312321(最大缓存时间) 或者 设置 expires 30d; (其实这两个都代表过期时间) 
并且设置etag off;
这时候便会将缓存交由给浏览器控制.

**感想**

写这篇东西的意义在哪里呢?
经过两个缓存方案的对比,我个人觉得通过etag或者lastModified方案来处理缓存是不错的选择.
因为这样前端可以不用去进行版本控制(毕竟做版本控制也需要借助工具来处理).
虽然说每次都会请求服务器.由服务器来决定是否重新下载.但所需时间是很小的.
但有个很大的局限就是,当我们使用webpack或者其他构建工具时候,一旦将整个dist删除再重新生成一份文件,会导致服务器以为该文件已经被修改过从而让浏览器重新下载.这使得etag和lastModified不适用于该场景.

**结语**

关于缓存方面的这里没有做细说,各位可以去搜索更详细的内容.
这里只是将前段时间遇到的问题和以及整个处理过程中自己的感想记录一下.
而我用的是webpack,所以最后的解决方案自然是用到第一种方案.即使用expires管理缓存.
如果有机会的话,我也会尝试使用etag来管理缓存,毕竟etag是比expire和cacheControl更新的一种方案.
但其实webpack的hash管理缓存也有坑的.这里不描述了.